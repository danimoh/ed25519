class ED25519 {
    static _awaitHandler() {
        if (!ED25519._handlerPromise) {
            ED25519._handlerPromise = new Promise((resolve, reject) => {
                // load the handler
                if (typeof(document) !== 'undefined') {
                    // we are in the browser
                    var script = document.createElement('script');
                    script.onload = resolve;
                    script.onerror = reject;
                    script.src = ED25519._path + (typeof(WebAssembly)!=='undefined'? 'ed25519-wasm.js' : 'ed25519-asm.js');
                    document.body.appendChild(script);
                } else {
                    // we are in node
                    if (typeof(WebAssembly)==='undefined') {
                        throw Error('Please use a node version with WebAssembly support.');
                    }
                    global.ED25519_HANDLER = require(ED25519._path + 'ed25519-wasm.js');
                    resolve();
                }
            })
            .then(() => new Promise((resolve, reject) => {
                ED25519._handler = ED25519_HANDLER({
                    wasmBinaryFile: ED25519._path + 'ed25519-wasm.wasm',
                    memoryInitializerPrefixURL: ED25519._path
                });
                // wait until the handler is ready
                ED25519._handler.onRuntimeInitialized = resolve;
            }))
            .then(() => {
                const memoryStart = ED25519._handler._get_static_memory_start();
                const memorySize = ED25519._handler._get_static_memory_size();
                if (memorySize < ED25519.PUBLIC_KEY_SIZE + ED25519.PRIVATE_KEY_SIZE + ED25519.SIGNATURE_SIZE) {
                    throw Error('Static memory too small');
                }
                let byteOffset = memoryStart;
                ED25519._pubKeyPointer = byteOffset;
                ED25519._pubKeyBuffer = new Uint8Array(ED25519._handler.HEAP8.buffer, byteOffset, ED25519.PUBLIC_KEY_SIZE);
                byteOffset += ED25519.PUBLIC_KEY_SIZE;
                ED25519._privKeyPointer = byteOffset;
                ED25519._privKeyBuffer = new Uint8Array(ED25519._handler.HEAP8.buffer, byteOffset, ED25519.PRIVATE_KEY_SIZE);
                byteOffset += ED25519.PRIVATE_KEY_SIZE;
                ED25519._signaturePointer = byteOffset;
                ED25519._signatureBuffer = new Uint8Array(ED25519._handler.HEAP8.buffer, byteOffset, ED25519.SIGNATURE_SIZE);
                byteOffset += ED25519.SIGNATURE_SIZE;
                ED25519._messagePointer = byteOffset;
                ED25519._messageBuffer = new Uint8Array(ED25519._handler.HEAP8.buffer, byteOffset, (memoryStart + memorySize) - byteOffset);
            });
        }
        return ED25519._handlerPromise;
    }


    static setPath(path) {
        if (ED25519._handlerPromise) {
            throw Error('path must be set before first call of any method');
        }
        ED25519._path = path;
    }


    /**
     * Calculate the public key for a given private key.
     * The private and public key are 32 byte. The private key can be any random data, however ensure to
     * use random data generated by a cryptographically secure random generator, e.g. window.crypto.getRandomValues.
     */
    static async derivePublicKey(out_publicKey, privateKey) {
        await ED25519._awaitHandler();
        if (out_publicKey.byteLength !== ED25519.PUBLIC_KEY_SIZE
            || privateKey.byteLength !== ED25519.PRIVATE_KEY_SIZE) {
            throw Error('Wrong buffer size.');
        }
        ED25519._privKeyBuffer.set(privateKey);
        ED25519._handler._ed25519_public_key_derive(ED25519._pubKeyPointer, ED25519._privKeyPointer);
        out_publicKey.set(ED25519._pubKeyBuffer);
        ED25519._privKeyBuffer.fill(0);
    }


    /**
     * Creates a signature of the given message with the given key pair. signature must be a writable 64 byte buffer.
     * message must have at least message_len bytes to be read and must fit into ED25519._messageBuffer.
     */
    static async sign(out_signature, message, publicKey, privateKey) {
        await ED25519._awaitHandler();
        const messageLength = message.byteLength;
        if (out_signature.byteLength !== ED25519.SIGNATURE_SIZE
            || messageLength > ED25519._messageBuffer.byteLength
            || publicKey.byteLength !== ED25519.PUBLIC_KEY_SIZE
            || privateKey.byteLength !== ED25519.PRIVATE_KEY_SIZE) {
            throw Error('Wrong buffer size.');
        }
        ED25519._messageBuffer.set(message);
        ED25519._pubKeyBuffer.set(publicKey);
        ED25519._privKeyBuffer.set(privateKey);
        ED25519._handler._ed25519_sign(ED25519._signaturePointer, ED25519._messagePointer, messageLength,
            ED25519._pubKeyPointer, ED25519._privKeyPointer);
        out_signature.set(ED25519._signatureBuffer);
        ED25519._privKeyBuffer.fill(0);
    }


    /**
     * Verifies the signature on the given message using public_key. signature must be a readable 64 byte buffer.
     * message must have at least message_len bytes to be read and must fit ED25519._messageBuffer.
     * Returns true if the signature matches, false otherwise.
     */
    static async verify(signature, message, publicKey) {
        await ED25519._awaitHandler();
        const messageLength = message.byteLength;
        if (signature.byteLength !== ED25519.SIGNATURE_SIZE
            || message.byteLength > ED25519._messageBuffer.byteLength
            || publicKey.byteLength !== ED25519.PUBLIC_KEY_SIZE) {
            throw Error('Wrong buffer size.');
        }
        ED25519._signatureBuffer.set(signature);
        ED25519._messageBuffer.set(message);
        ED25519._pubKeyBuffer.set(publicKey);
        return !!ED25519._handler._ed25519_verify(ED25519._signaturePointer, ED25519._messagePointer, messageLength,
            ED25519._pubKeyPointer);
    }
}

ED25519.PUBLIC_KEY_SIZE = 32;
ED25519.PRIVATE_KEY_SIZE = 32;
ED25519.SIGNATURE_SIZE = 64;

ED25519._pubKeyBuffer = null;
ED25519._privKeyBuffer = null;
ED25519._signatureBuffer = null;
ED25519._messageBuffer = null;

ED25519._pubKeyPointer = null;
ED25519._privKeyPointer = null;
ED25519._signaturePointer = null;
ED25519._messagePointer = null;

ED25519._path = '../node_modules/ed25519/dist/';
ED25519._handler = null;
ED25519._handlerPromise = null;

if (typeof(Class) !== 'undefined') {
    // support for nimiqs class system
    Class.register(ED25519);
}
if (typeof(module) !== 'undefined') {
    module.exports = ED25519;
}